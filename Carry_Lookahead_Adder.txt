module CLA_32bit(a, b, ci, sum, cout);
	input	[31:0] a;
	input	[31:0] b;
	input	ci;
	output	[31:0] sum;
	output 	cout;
	
	wire [7:0]	GG;
	wire [7:0]	PP;
	wire [7:1]	C;
	
	CLALogic_8 CarryLogic_2 (GG[7:0], PP[7:0], ci, C[7:1], cout, GGG, PPP);
	
	CLA8 u0 (a[ 7:0], b[ 7: 0],   ci,   sum[ 7: 0],   GG[0], PP[0]);
	CLA8 u1 (a[ 15:8], b[ 15: 8],   C[1], sum[ 15: 8],   GG[1], PP[1]);
	CLA8 u2 (a[ 23:16], b[ 23: 16], C[2], sum[ 23: 16],  GG[2], PP[2]);
	CLA8 u3 (a[ 31:24], b[ 31: 24], C[3], sum[ 31: 24], GG[3], PP[3]);

endmodule //이 부분은 연결이라서 나중에 해도 괜찮을 듯.

module CLA8(A, B, Ci, S, GG, PP);
	input [7:0] A;
	input [7:0] B;
	input Ci;
	output [7:0] S;
	output PP;
	output GG;
	
	wire [7:0] G;
	wire [7:0] P;
	wire [7:1] C;
	
	CLALogic_8 CarryLogic (G, P, Ci, C, Co, GG, PP);
	GPFullAdder FA0 (A[0], B[0], Ci, G[0], P[0], S[0]);
	GPFullAdder FA1 (A[1], B[1], C[1], G[1], P[1], S[1]);
	GPFullAdder FA2 (A[2], B[2], C[2], G[2], P[2], S[2]);
	GPFullAdder FA3 (A[3], B[3], C[3], G[3], P[3], S[3]);
	GPFullAdder FA4 (A[4], B[4], C[4], G[4], P[4], S[4]);
	GPFullAdder FA5 (A[5], B[5], C[5], G[5], P[5], S[5]);
	GPFullAdder FA6 (A[6], B[6], C[6], G[6], P[6], S[6]);
	GPFullAdder FA7 (A[7], B[7], C[7], G[7], P[7], S[7]);
endmodule

module GPFullAdder(X, Y, Cin, G, P, Sum);
	input X;
	input Y;
	input Cin;
	output G;
	output P;
	output Sum;
	
	assign G = X & Y;
	assign P = X ^ Y;
	assign Sum = P ^ Cin;
endmodule

module CLALogic_8(G, P, Ci, C, Co, GG, PP);
	input [7:0] G;
	input [7:0]	P;
	input Ci;
	output [7:1] C; //여기가 왜 3비트인지 잘 이해가 안가넹
	output Co;
	output GG;
	output PP;
	
	assign PP = P[7] & P[6] & P[5] & P[4] & P[3] & P[2] & P[1] & P[0];
	assign GG = G[7] | (P[7] & G[6]) | (P[7] & P[6] & G[5]) | (P[7] & P[6] & P[5] & G[4]) | (P[7] & P[6] & P[5] & P[4] & G[3]) | (P[7] & P[6] & P[5] & P[4] & P[3] & G[2]) | (P[7] & P[6] & P[5] & P[4] & P[3] & P[2] & G[1]) | (P[7] & P[6] & P[5] & P[4] & P[3] & P[2] & P[1] & G[0]); 
	assign Co = GG | (PP & Ci);
	assign C[1] = G[0] | (P[0] & Ci);
	assign C[2] = G[1] | (P[1] & G[0]) | (P[1] & P[0] & Ci);
	assign C[3] = G[2] | (P[2] & G[1]) | (P[2] & P[1] & G[0]) | (P[2] & P[1] & P[0] & Ci);
	assign C[4] = G[3] | (P[3] & G[2]) | (P[3] & P[2] & G[1]) | (P[3] & P[2] & P[1] & G[0]) | (P[3] & P[2] & P[1] & P[0] & Ci);
	assign C[5] = G[4] | (P[4] & G[3]) | (P[4] & P[3] & G[2]) | (P[4] & P[3] & P[2] & G[1]) | (P[4] & P[3] & P[2] & P[1] & G[0]) | (P[4] & P[3] & P[2] & P[1] & P[0] & Ci);
	assign C[6] = G[5] | (P[5] & G[4]) | (P[5] & P[4] & G[3]) | (P[5] & P[4] & P[3] & G[2]) | (P[5] & P[4] & P[3] & P[2] & G[1]) | (P[5] & P[4] & P[3] & P[2] & P[1] & G[0]) | (P[5] & P[4] & P[3] & P[2] & P[1] & P[0] & Ci);
	assign C[7] = G[6] | (P[6] & G[5]) | (P[6] & P[5] & G[4]) | (P[6] & P[5] & P[4] & G[3]) | (P[6] & P[5] & P[4] & P[3] & G[2]) | (P[6] & P[5] & P[4] & P[3] & P[2] & G[1]) | (P[6] & P[5] & P[4] & P[3] & P[2] & P[1] & G[0]) | (P[6] & P[5] & P[4] & P[3] & P[2] & P[1] & P[0] & Ci);
endmodule

